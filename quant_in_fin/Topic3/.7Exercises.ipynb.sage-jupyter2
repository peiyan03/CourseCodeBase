{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-72815527-1f1d-4a55-9acb-236a05b12f5a.json","kernel":"anaconda2020","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_backend_state":1761231945280,"last_ipynb_save":1761231945408,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.7.8"},"nbgrader":{"__altered":false,"__hash":-564582466,"_root":{"entries":[["size",5],["_root",{"entries":[["size",5],["_root",{"entries":[["__altered",false],["__hash",229782201],["_root",{"entries":[["size",5],["_root",{"entries":[["size",5],["_root",{"entries":[["size",1],["_root",{"entries":[["cocalc_minimal_stubs",false]],"ownerID":{}}],["__hash",-335098374],["__altered",false],["cocalc_minimal_stubs",false]],"ownerID":{}}],["__hash",1043241747],["__altered",false],["cocalc_minimal_stubs",false]],"ownerID":{}}],["__hash",-3618366],["__altered",false],["cocalc_minimal_stubs",false]],"ownerID":{}}],["cocalc_minimal_stubs",false],["size",5]],"ownerID":{}}],["__hash",168019484],["__altered",false],["cocalc_minimal_stubs",false]],"ownerID":{}}],["__hash",-187269455],["__altered",false],["cocalc_minimal_stubs",false]],"ownerID":{}},"cocalc_minimal_stubs":false,"size":5}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1760919364943,"exec_count":2,"id":"4778b9","input":"(3500-2500)/2500","kernel":"anaconda2020","metadata":{"deletable":false,"nbgrader":{"cell_type":"code","checksum":"97af574f90860815ce94c18bd64e1027","grade":false,"grade_id":"4778b9","locked":false,"schema_version":3,"solution":true,"task":false}},"output":{"0":{"data":{"text/plain":"0.4"},"exec_count":2}},"pos":3,"start":1760919364936,"state":"done","type":"cell"}
{"cell_type":"code","end":1760919366565,"exec_count":3,"id":"56c4ed","input":"check('56c4ed',_)\nauto_marking_message()","kernel":"anaconda2020","metadata":{"deletable":false,"editable":false,"nbgrader":{"cell_type":"code","checksum":"115b7caed1b67f7f25060452aaa52a4d","grade":true,"grade_id":"56c4ed","locked":true,"points":1,"schema_version":3,"solution":false,"task":false}},"output":{"0":{"name":"stdout","text":"Auto marking message: üèÜ Correct\n"}},"pos":4,"start":1760919366558,"state":"done","type":"cell"}
{"cell_type":"code","end":1761218727789,"exec_count":4,"id":"732b6f","input":"import pandas as pd\nimport matplotlib.pyplot as plt\n\n\n# 1) Load\ndf = pd.read_excel(\"goog-options.xlsx\")\n\n# 2) Infer/normalize columns ‚Üí security, last, mid, strike\nlower_cols = [str(c).strip().lower() for c in df.columns]\nname_map = {}\nfor i, c in enumerate(lower_cols):\n    if \"sec\" in c:      name_map[i] = \"security\"\n    elif \"last\" in c:   name_map[i] = \"last\"\n    elif \"mid\" in c:    name_map[i] = \"mid\"\n    elif \"strike\" in c: name_map[i] = \"strike\"\n\n# Fallback to positional order if needed: [security, last, mid, strike]\nif set(name_map.values()) != {\"security\", \"last\", \"mid\", \"strike\"}:\n    if df.shape[1] < 4:\n        raise ValueError(\"Expected at least 4 columns: security, last, mid, strike.\")\n    name_map = {0: \"security\", 1: \"last\", 2: \"mid\", 3: \"strike\"}\n\n# Rename\ndf = df.rename(columns={df.columns[i]: new for i, new in name_map.items()})\n\n# 3) Keep only needed columns, coerce to numeric\ndf = df[[\"security\", \"last\", \"mid\", \"strike\"]].copy()\ndf[\"mid\"] = pd.to_numeric(df[\"mid\"], errors=\"coerce\")\ndf[\"strike\"] = pd.to_numeric(df[\"strike\"], errors=\"coerce\")\n\n# 4) Optional: drop rows missing mid/strike and sort by strike (helps plotting)\ndf = df.dropna(subset=[\"mid\", \"strike\"]).sort_values(\"strike\")\n\n# 5) Sum of all mid prices (as required)\nsum_mids = df[\"mid\"].sum()\n\n# 6) Plot mid vs strike\nplt.figure()\nplt.plot(df[\"strike\"], df[\"mid\"], marker=\"o\", linestyle=\"-\")\nplt.xlabel(\"Strike price\")\nplt.ylabel(\"Mid price\")\nplt.title(\"GOOG Call Options: Mid vs Strike\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\nprint(\"sum_mids =\", sum_mids)","kernel":"anaconda2020","metadata":{"deletable":false,"nbgrader":{"cell_type":"code","checksum":"d023790553390e4682ac82ba43d03b9d","grade":false,"grade_id":"732b6f","locked":false,"schema_version":3,"solution":true,"task":false}},"output":{"0":{"data":{"image/png":"3e17b3924b791100abe129f17ad200ca0c0c0a3f","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":495,"width":856},"needs_background":"light"}},"1":{"name":"stdout","text":"sum_mids = 2242.975\n"}},"pos":8,"start":1761218726999,"state":"done","type":"cell"}
{"cell_type":"code","end":1761218741845,"exec_count":7,"id":"7420b9","input":"check('7420b',sum_mids)\nauto_marking_message()","kernel":"anaconda2020","last":326,"metadata":{"deletable":false,"editable":false,"nbgrader":{"cell_type":"code","checksum":"f8a0dd44fe80512f50fbce5e8f2495c5","grade":true,"grade_id":"7420b9","locked":true,"points":1,"schema_version":3,"solution":false,"task":false}},"output":{"0":{"name":"stdout","text":"Auto marking message: üèÜ Correct\n"}},"pos":9,"start":1761218741819,"state":"done","type":"cell"}
{"cell_type":"code","end":1761229322094,"exec_count":6,"id":"e7f108","input":"from grading_tools import check, auto_marking_message\nimport cvxopt\nimport numpy as np\nfrom math import *\nimport matplotlib.pyplot as plt","kernel":"anaconda2020","last":54,"pos":0,"start":1761229321914,"state":"done","type":"cell"}
{"cell_type":"code","end":1761229626594,"exec_count":14,"id":"60c910","input":"# So you don't have to keep retyping the same\n# code, I've created two handy functions read_return_history and solve_markowitz\n# in the file markowitzlib.py which you can use. \nfrom markowitzlib import read_return_history\n\n# --- Get the matrix of returns ---\nreturn_history = read_return_history()\n\n# --- Take first stock's returns ---\nfirst_stock_returns = return_history[:, 0]\n\n# --- Plot the historic weekly returns ---\nplt.figure(figsize=(10, 4))\nplt.plot(first_stock_returns, label=\"Historic Weekly Returns\")\nplt.xlabel(\"Week\")\nplt.ylabel(\"Return\")\nplt.title(\"Historic Weekly Return of First Stock\")\nplt.legend()\nplt.show()\n\n# --- Generate a synthetic normal series with same mean/std ---\nmu = np.mean(first_stock_returns)\nsigma = np.std(first_stock_returns)\nsynthetic_returns = np.random.normal(mu, sigma, len(first_stock_returns))\n\n# --- Plot the synthetic returns ---\nplt.figure(figsize=(10, 4))\nplt.plot(synthetic_returns, color=\"orange\", label=\"Synthetic (Normal) Returns\")\nplt.xlabel(\"Week\")\nplt.ylabel(\"Return\")\nplt.title(\"Synthetic Normally Distributed Returns (same Œº, œÉ)\")\nplt.legend()\nplt.show()\n\n# --- Print comparison stats ---\nprint(f\"Historic mean = {mu:.6f}, std = {sigma:.6f}\")\nprint(f\"Synthetic mean = {np.mean(synthetic_returns):.6f}, std = {np.std(synthetic_returns):.6f}\")","kernel":"anaconda2020","last":1835,"metadata":{"deletable":false,"nbgrader":{"cell_type":"code","checksum":"15482d987321dbb90b5d52481dc8bfa0","grade":false,"grade_id":"60c910","locked":false,"schema_version":3,"solution":true,"task":false}},"output":{"0":{"data":{"image/png":"6ba8a8d322111d83af71e60033c0bd183c0397ca","text/plain":"<Figure size 720x288 with 1 Axes>"},"metadata":{"image/png":{"height":277,"width":617},"needs_background":"light"}},"1":{"data":{"image/png":"554c7f9e9a479fb1c5e69c64dbd114b962baccb1","text/plain":"<Figure size 720x288 with 1 Axes>"},"metadata":{"image/png":{"height":277,"width":623},"needs_background":"light"}},"2":{"name":"stdout","text":"Historic mean = 0.002396, std = 0.056231\nSynthetic mean = 0.002768, std = 0.056423\n"}},"pos":6,"start":1761229624003,"state":"done","type":"cell"}
{"cell_type":"code","id":"1cf82d","input":"from markowitzlib import read_return_history as rrh\nreturn_history = rrh()\n\nmu = np.mean( return_history, axis=0 )\nsigma = np.cov( return_history, rowvar=False )\nres = solve_markowitz(sigma, mu, 0.003, True)\ncheck( '1cf82d.1', res['sd'], tol=0.000001 )\nres = solve_markowitz(sigma, mu, 0.003, False)\ncheck( '1cf82d.2', res['sd'], tol =0.000001 )\n\nfor allow_short_selling in [True, False]:\n    mu = np.mean( return_history, axis=0 )\n    sigma = np.cov( return_history, rowvar=False )\n    returns = np.linspace(0,0.007,50)\n    min_sds = np.zeros(len(returns))\n    for i in range(0,len(returns)):\n        ret = solve_markowitz(sigma, mu, returns[i], allow_short_selling)\n        min_sds[i] = ret['sd']\n\n    ax = plt.gca()\n    if allow_short_selling:\n        l = 'Short-selling allowed'\n    else:\n        l = 'Short-selling prohibited'\n    ax.plot(min_sds,returns, label=l);\n    \nax.legend();\nauto_marking_message()","metadata":{"deletable":false,"editable":false,"nbgrader":{"cell_type":"code","checksum":"4c5e18d3a1e44bbc086498e9f345b6f3","grade":true,"grade_id":"1cf82d","locked":true,"points":1,"schema_version":3,"solution":false,"task":false}},"pos":12,"type":"cell"}
{"cell_type":"code","id":"39bbd4","input":"# The next line stops the CVX optimiser filling your notebook with\n# output: it produces a lot of annoying print out if you run it\n# to solve the problem with short-selling prohibited.\ncvxopt.solvers.options['show_progress'] = False\n\ndef solve_markowitz( sigma, mu, R, allow_short_selling = True ):\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\nfrom markowitzlib import read_return_history as rrh\nreturn_history = rrh()\nmu = np.mean( return_history, axis = 0)\nprint(mu[0])","metadata":{"deletable":false,"nbgrader":{"cell_type":"code","checksum":"3944df685218992730f98d073d02e010","grade":false,"grade_id":"39bbd4","locked":false,"schema_version":3,"solution":true,"task":false}},"pos":11,"type":"cell"}
{"cell_type":"code","id":"a95832","input":"n = 7\nw = find_weights(n)\nassert len(w)==7\ncheck('cbd518.1', w.transpose() @ w)\ncheck('cbd518.2', sum(w))\nauto_marking_message()","metadata":{"deletable":false,"editable":false,"nbgrader":{"cell_type":"code","checksum":"a496c0484b57083bdbe7a22614b082ea","grade":true,"grade_id":"a95832","locked":true,"points":1,"schema_version":3,"solution":false,"task":false}},"pos":15,"slide":"skip","type":"cell"}
{"cell_type":"code","id":"cbd518","input":"def find_weights( n ):\n    # YOUR CODE HERE\n    raise NotImplementedError()","metadata":{"deletable":false,"nbgrader":{"cell_type":"code","checksum":"185114a6597a84dfb6e27013a39d929f","grade":false,"grade_id":"cbd518","locked":false,"schema_version":3,"solution":true,"task":false}},"pos":14,"slide":"skip","type":"cell"}
{"cell_type":"markdown","id":"069e0a","input":"## Exercise\n\nThe file `goog-options.xlsx` contains data for option prices on Google stock taken on one particular day. Use the \"explorer\" tab on Cocalc to view all the files in this directory which includes this goog\\-options.xslx file so you can download it to view it.\n\nEach row in the main table represents the price of a different call option. The first column contains an identifier for the specific call option contract. The word _security_ is used to refer to a general financial product whether it is a stock, bond, option \\(or any other kind of financial product\\), so this identifier is called a _security identifier_.\n\nThe second column contains the *last price* of the option and the third price is the *mid price*\nThere are two main prices quoted for any financial product on the market. The ask price is how much you must pay to buy a product, the bid price is how much you will receive if you sell the product. The mid price is the average of the two. The last price is the last price traded, which may be either the bid or the ask.\n\nThe final column contains the strike price of each option.\n\nPlot a graph of the mid price against the strike price.\n\nSo I can test your code, store the sum of all the mid prices in a variable called `sum_mids`.\n\n","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"13b5c1","input":"## Exercise\n\nConsider a portfolio of 3 assets with means' ${\\bf\\mu}=(0.1, 0.05,0.15)$ and covariance matrix $\\Sigma = I_3$, the $3\\times 3$ identity matrix.\nUsing the method of Lagrange multipliers, determine the weights of the minimum variance portfolio that achieve return $R$.\n\nSketch the efficient frontier in this case, marking the global minimum variance point and $\\sigma$ intercept.\n\n","pos":17,"slide":"slide","type":"cell"}
{"cell_type":"markdown","id":"1b84fa","input":"## Exercise\n\nConsider an $n$\\-asset portfolio as defined in lectures. Using our expression for the weights for the minimum variance portfolio for a given return $R$, it can be shown that the efficient frontier is \n$$\n\\sigma^2_p = \\frac{AR^2 - 2BR + C}{AC-B^2}.\n$$\nWhat is the global minimum variance portfolio? Provide its expected return and weights as well as the variance.\n\n","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"b2a0d9","input":"# Exercises","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"b8a4d5","input":"## Exercise\n\nIf you invest $\\$2500$ in Google stock and it grows to have a value of $\\$3500$, what is your return?  \n\n","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"c0b97c","input":"## Exercise\n\nPlot a chart of the historic weekly return of the first stock in the `ukx.xlsx` file. It should be very spiky and look a lot a graph of white noise.\n\nHow would you generate a sequence of normally distributed random numbers with the same mean and standard deviation as the returns of this first stock? Generate a plot of such random numbers that can be compared with the plot of historic weekly returns.\n\nCan you visually detect any differences between the plots?","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"f60404","input":"## Exercise\n\nSuppose that the market contains $n$ stocks. Suppose that the returns of the stocks over the time period $0$ to $T$ are given by independent identically distributed random variables\n$R_1$, $R_2$, ..., $R_n$ each with mean $\\mu$ and standard deviation $\\sigma$. Find the weights of a portfolio whose return is $\\mu$\nand whose standard deviation is\n$$\\frac{1}{\\sqrt{n}}\\sigma.$$\n\n**Hint:** What is the most diversified possible investment across these stocks?\n\n","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"ffba8b","input":"## Exercise\n\nSuppose that short-selling is not allowed, so all the components of the weight vector must be positive. Write down a version of the optimization problem where short-selling is not allowed. Write a Python function that can solve this problem given a covariance matrix $\\Sigma$ and mean vector $\\mu$. This should work exactly like the `solve_markowitz` function in the handout except that it should be able to solve\nthe problem when short-selling is allowed and when short-selling is not allowed.\n\nIf short-selling is not allowed, then not all return values can actually be achieved, so sometimes your program will fail saying that the optimization is not feasible. However, I found that for the $\\Sigma$ and $\\mu$ used in the previous video that you can find solutions for expected returns in the range from 0 to 0.007.\n\nIf your code is correct, then the tests will plot a graph showing how the efficient frontier changes when short-selling is allowed\nor not allowed.","pos":10,"type":"cell"}
{"id":0,"time":1761231915289,"type":"user"}
{"last_load":1760919319793,"type":"file"}